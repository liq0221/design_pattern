#  设计模式
## 单例模式
    确保一个类只有一个实例，并提供全局访问点。
## 策略模式
    定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
## 工厂模式
    定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法是让类把实例化推迟到子类。
## 观察者模式
    在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知，并自动更新。
## 装饰者模式
    动态的将责任附加到对象身上。想要扩展功能，装饰着提供有别于继承的另一种选择。
## 命令模式
    将请求封装成对象，这可以让你 使用不同的请求、队列、或者日志请求来参数化其他对象。命令模式也支持撤销操作。
## 代理模式
    为另一个对象提供一个替身或占位符以访问这个对象。
## 组合模式
    将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户可以使用一致的方法操作单个对象和组合对象。
## 享元模式
    运用共享技术有效地支持大量细粒度对象的利用。通过共享已经存在的对象来大幅度减少对象数量、避免大量相似类的开销，从而提高资源利用率。
## 适配器模式
    将一个类的接口转换成客户期望的另一个接口。适配器可以让原来不兼容的类可以兼容。
## 外观模式
    提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
## 模板模式
    在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
## 迭代器模式
    提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的元素。
## 访问者模式
## 责任链模式
## 状态模式
    允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
## 创建型
    Singleton、Builder、Prototype、AbstractFactory、Factory Method
##  行为型
    Mediator、Template Method、Visitor、Iterator、Command、Memnto、Interpreter、Observer、State、Strategy、Chain of Responsibility
## 结构型
    Decorator、Proxy、Composite、Facade、Bridge、Flyweight、Adaptor
## 类
    Template Method、Factory Method、Adaptor、Intercepter
## 对象
    Composite、Singleton、Visitor、AbstractFactory、Strategy、State、Facade、Mediator、Observer、Command、Memnto、Flyweight、Iterator、Bridge、Builder、Prototype、Chain of Responsibility、Proxy