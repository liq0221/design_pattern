#  设计模式
## 单例模式(确保有且只有一个对象被创建)
    确保一个类只有一个实例，并提供全局访问点。
## 策略模式(封装可以互换的行为，并使用委托来决定使用哪一个)
    定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
## 抽象工厂模式(允许客户创建对象的家族，而无需指定他们的具体类)
    定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法是让类把实例化推迟到子类。
## 观察者模式(让对象能够在状态改变是被通知)
    在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知，并自动更新。
## 装饰者模式(包装一个新的对象，以提供新的行为)
    动态的将责任附加到对象身上。想要扩展功能，装饰着提供有别于继承的另一种选择。
## 命令模式(封装请求成为对象)
    将请求封装成对象，这可以让你 使用不同的请求、队列、或者日志请求来参数化其他对象。命令模式也支持撤销操作。
## 代理模式(包装对象，以控制对此对象的访问)
    为另一个对象提供一个替身或占位符以访问这个对象。
## 组合模式(客户用一致的方式处理对象集合和单个对象)
    将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户可以使用一致的方法操作单个对象和组合对象。
## 享元模式
    运用共享技术有效地支持大量细粒度对象的利用。通过共享已经存在的对象来大幅度减少对象数量、避免大量相似类的开销，从而提高资源利用率。
## 适配器模式(封装对象，并提供不同的接口)
    将一个类的接口转换成客户期望的另一个接口。适配器可以让原来不兼容的类可以兼容。
## 外观模式(简化一群类的接口)
    提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
## 模板模式(由子类决定如何实现一个算法中的步骤)
    在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
## 迭代器模式(在对象的集合中游走，而不暴露集合的实现)
    提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的元素。
## 访问者模式
    封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
## 状态模式(封装了基于状态的行为，并使用委托在行为之间切换)
    允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
## 建造者模式
    使用多个简单的对象一步步构建成复杂的对象。
## 桥接模式
    将抽象部分与实现部分分离，使它们可以独立地变化。
## 备忘录模式
    保存对象状态信息(快照)、撤销、重做和历史记录。
## 原型模式
    将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象克隆自己来实现创建过程。
## 责任链模式


## 创建型
    Singleton、Builder、Prototype、AbstractFactory、Factory Method
##  行为型
    Mediator、Template Method、Visitor、Iterator、Command、Memnto、Interpreter、Observer、State、Strategy、Chain of Responsibility
## 结构型
    Decorator、Proxy、Composite、Facade、Bridge、Flyweight、Adaptor
## 类
    Template Method、Factory Method、Adaptor、Intercepter
## 对象
    Composite、Singleton、Visitor、AbstractFactory、Strategy、State、Facade、Mediator、Observer、Command、Memnto、Flyweight、Iterator、Bridge、Builder、Prototype、Chain of Responsibility、Proxy